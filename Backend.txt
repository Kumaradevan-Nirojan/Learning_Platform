backend\config\db.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log(`âœ… MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`âŒ MongoDB Error: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

backend\controllers\courseController.js
const mongoose = require('mongoose');
const asyncHandler = require('express-async-handler');
const Course = require('../models/Course');
const Enrollment = require('../models/Enrollment');


// GET all courses
exports.getCourses = asyncHandler(async (req, res) => {
  const courses = await Course.find({}).populate('educator', 'firstName lastName');
  res.json(courses);
});

// GET course by ID
exports.getCourseById = asyncHandler(async (req, res) => {
  const course = await Course.findById(req.params.id).populate('educator', 'firstName lastName');
  if (!course) {
    res.status(404);
    throw new Error('Course not found');
  }
  res.json(course);
});

// CREATE course
exports.createCourse = asyncHandler(async (req, res) => {
  const newCourse = new Course(req.body);
  const saved = await newCourse.save();
  res.status(201).json(saved);
});

// UPDATE course
exports.updateCourse = asyncHandler(async (req, res) => {
  const course = await Course.findById(req.params.id);
  if (!course) {
    res.status(404);
    throw new Error('Course not found');
  }

  Object.assign(course, req.body);
  const updated = await course.save();
  res.json(updated);
});

// DELETE course
exports.deleteCourse = asyncHandler(async (req, res) => {
  const course = await Course.findById(req.params.id);
  if (!course) {
    res.status(404);
    throw new Error('Course not found');
  }
  await course.remove();
  res.json({ message: 'Course removed' });
});

// GET courses with enrolled learners and marks (defensive version using "learner" field)
exports.getCoursesWithStudentsAndMarks = asyncHandler(async (req, res) => {
  try {
    const { educator, title, category, startDate, endDate } = req.query;

    const match = {};
    if (educator && mongoose.Types.ObjectId.isValid(educator)) {
      match.educator = new mongoose.Types.ObjectId(educator);
    }
    if (title && title.trim() !== '') {
      match.title = { $regex: title.trim(), $options: 'i' };
    }
    if (category && category.trim() !== '') {
      match.category = { $regex: category.trim(), $options: 'i' };
    }
    if (startDate || endDate) {
      match.startDate = {};
      if (startDate) match.startDate.$gte = new Date(startDate);
      if (endDate) match.startDate.$lte = new Date(endDate);
    }

    const courses = await Course.aggregate([
      { $match: match },
      {
        $lookup: {
          from: 'educators',
          localField: 'educator',
          foreignField: '_id',
          as: 'educatorDetails'
        }
      },
      { $unwind: { path: '$educatorDetails', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'enrollments',
          localField: '_id',
          foreignField: 'course',
          as: 'enrollments'
        }
      },
      { $unwind: { path: '$enrollments', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'users',
          localField: 'enrollments.learner',
          foreignField: '_id',
          as: 'learnerInfo'
        }
      },
      { $unwind: { path: '$learnerInfo', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'submissions',
          let: { courseId: '$_id', learnerId: '$learnerInfo._id' },
          pipeline: [
            {
              $match: {
                $expr: {
                  $and: [
                    { $eq: ['$course', '$$courseId'] },
                    { $eq: ['$learner', '$$learnerId'] }
                  ]
                }
              }
            },
            { $group: { _id: null, avgMark: { $avg: '$mark' } } }
          ],
          as: 'assignmentMarks'
        }
      },
      {
        $lookup: {
          from: 'quizzes',
          let: { courseId: '$_id', learnerId: '$learnerInfo._id' },
          pipeline: [
            {
              $match: {
                $expr: {
                  $and: [
                    { $eq: ['$course', '$$courseId'] },
                    { $eq: ['$learner', '$$learnerId'] }
                  ]
                }
              }
            },
            { $group: { _id: null, avgMark: { $avg: '$mark' } } }
          ],
          as: 'quizMarks'
        }
      },
      {
        $addFields: {
          student: {
            name: {
              $cond: [
                {
                  $and: [
                    { $ifNull: ['$learnerInfo.firstName', false] },
                    { $ifNull: ['$learnerInfo.lastName', false] }
                  ]
                },
                {
                  $concat: ['$learnerInfo.firstName', ' ', '$learnerInfo.lastName']
                },
                'Unknown Learner'
              ]
            },
            assignmentMark: {
              $round: [{ $ifNull: [{ $arrayElemAt: ['$assignmentMarks.avgMark', 0] }, 0] }, 2]
            },
            quizMark: {
              $round: [{ $ifNull: [{ $arrayElemAt: ['$quizMarks.avgMark', 0] }, 0] }, 2]
            }
          }
        }
      },
      {
        $group: {
          _id: '$_id',
          title: { $first: '$title' },
          category: { $first: '$category' },
          venue: { $first: '$venue' },
          medium: { $first: '$medium' },
          startDate: { $first: '$startDate' },
          endDate: { $first: '$endDate' },
          educator: {
            $first: {
              $cond: [
                { $ifNull: ['$educatorDetails.firstName', false] },
                '$educatorDetails.firstName',
                'N/A'
              ]
            }
          },
          students: {
            $push: {
              name: '$student.name',
              assignmentMark: '$student.assignmentMark',
              quizMark: '$student.quizMark'
            }
          }
        }
      },
      { $sort: { startDate: -1 } }
    ]);

    res.json(courses);
  } catch (error) {
    console.error('Error fetching courses with learners and marks:', error.message);
    res.status(500).json({ message: 'Server error occurred while fetching learner data.' });
  }
});

// âœ… Get courses with enrolled learners
exports.getCoursesWithStudents = asyncHandler(async (req, res) => {
  const enrollments = await Enrollment.find()
    .populate('learner', 'firstName lastName email')
    .populate('course', 'title category');

  // Group learners under each course
  const grouped = {};
  enrollments.forEach(enr => {
    const courseId = enr.course._id.toString();
    if (!grouped[courseId]) {
      grouped[courseId] = {
        _id: enr.course._id,
        title: enr.course.title,
        category: enr.course.category,
        learners: [],
      };
    }

    grouped[courseId].learners.push({
      _id: enr.learner._id,
      firstName: enr.learner.firstName,
      lastName: enr.learner.lastName,
      email: enr.learner.email,
    });
  });

  res.json(Object.values(grouped));
});

backend\controllers\dashboardController.js
const Course = require('../models/Course');
const Assignment = require('../models/Assignment');
const Submission = require('../models/Submission');

exports.getEducatorDashboardMetrics = async (req, res) => {
  try {
    const educatorId = req.user._id;

    const coursesCount = await Course.countDocuments({ educator: educatorId });
    const assignments = await Assignment.find({ educator: educatorId }).select('_id');
    const assignmentIds = assignments.map(a => a._id);

    const assignmentsCount = assignmentIds.length;

    const submissions = await Submission.find({ assignment: { $in: assignmentIds } });
    const submissionsCount = submissions.length;

    const gradedSubmissions = submissions.filter(s => s.grade !== undefined && s.grade !== null);
    const gradedCount = gradedSubmissions.length;

    const averageGrade =
      gradedCount > 0
        ? gradedSubmissions.reduce((sum, s) => sum + parseFloat(s.grade), 0) / gradedCount
        : 0;

    res.status(200).json({
      coursesCount,
      assignmentsCount,
      submissionsCount,
      gradedCount,
      averageGrade: averageGrade.toFixed(2),
    });
  } catch (error) {
    console.error("Educator metrics fetch error:", error.message);
    res.status(500).json({ message: 'Failed to fetch educator dashboard metrics' });
  }
};

backend\controllers\educatorController.js
// backend/controllers/educatorController.js

const User = require('../models/User');

// âœ… GET all users with role: 'educator'
const getAllEducators = async (req, res) => {
  try {
    const educators = await User.find({ role: 'educator' }).select('-password');
    res.status(200).json(educators);
  } catch (err) {
    console.error('Error fetching educators:', err);
    res.status(500).json({ message: 'Failed to retrieve educators' });
  }
};

// âœ… DELETE educator by ID
const deleteEducator = async (req, res) => {
  try {
    const educator = await User.findOneAndDelete({ _id: req.params.id, role: 'educator' });
    if (!educator) {
      return res.status(404).json({ message: 'Educator not found' });
    }
    res.status(200).json({ message: 'Educator deleted successfully' });
  } catch (err) {
    console.error('Error deleting educator:', err);
    res.status(500).json({ message: 'Failed to delete educator' });
  }
};

// âœ… NEW: Toggle educator active/inactive status
const toggleEducatorStatus = async (req, res) => {
  try {
    const educator = await User.findById(req.params.id);
    if (!educator || educator.role !== 'educator') {
      return res.status(404).json({ message: 'Educator not found' });
    }

    educator.isActive = !educator.isActive;
    await educator.save();

    res.status(200).json({
      message: `Educator is now ${educator.isActive ? 'Active' : 'Inactive'}`,
      isActive: educator.isActive,
    });
  } catch (err) {
    console.error('Error toggling educator status:', err);
    res.status(500).json({ message: 'Failed to update educator status' });
  }
};

module.exports = {
  getAllEducators,
  deleteEducator,
  toggleEducatorStatus, // âœ… Exported new function
};

backend\controllers\enrollmentController.js
const asyncHandler = require('express-async-handler');
const Enrollment = require('../models/Enrollment');
const Course = require('../models/Course');
const User = require('../models/User');
const path = require('path');
const { generateReceiptPDF } = require('../utils/reportUtils');

// ... [Other existing functions remain unchanged] ...

// âœ… Get learners with their enrolled courses (Enhanced)
exports.getLearnersWithEnrollments = asyncHandler(async (req, res) => {
  const role = req.user.role;
  if (role !== 'coordinator') {
    res.status(403);
    throw new Error('Only coordinators can access this data');
  }

  const enrollments = await Enrollment.find()
    .populate('learner', 'firstName lastName email phone country')
    .populate('course', 'title startDate category');

  const grouped = {};
  enrollments.forEach(enr => {
    const learnerId = enr.learner._id.toString();
    if (!grouped[learnerId]) {
      grouped[learnerId] = {
        ...enr.learner.toObject(),
        enrolledCourses: [],
      };
    }

    grouped[learnerId].enrolledCourses.push({
      _id: enr.course._id,
      title: enr.course.title,
      enrolledAt: enr.enrollmentDate,
      enrollmentId: enr._id, // âœ… Added: Used for unenrolling
    });
  });

  res.json(Object.values(grouped));
});

// âœ… New: Unenroll learner using enrollmentId
exports.unenrollLearnerFromCourseByEnrollmentId = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const enrollment = await Enrollment.findById(id);
  if (!enrollment) {
    res.status(404);
    throw new Error('Enrollment not found');
  }

  await enrollment.remove();
  res.json({ message: 'Learner unenrolled successfully' });
});

backend\controllers\evaluationController.js
const asyncHandler = require('express-async-handler');
const Evaluation = require('../models/Evaluation');
const User = require('../models/User');
const Course = require('../models/Course');

// @desc    Create a new evaluation
// @route   POST /api/v1/evaluations
// @access  Private (educator, coordinator)
exports.createEvaluation = asyncHandler(async (req, res) => {
  const { learner, course, feedback, grade } = req.body;

  if (!learner || !course || !feedback) {
    res.status(400);
    throw new Error('Learner, course, and feedback are required');
  }

  // Validate user role and existence
  const learnerUser = await User.findById(learner);
  if (!learnerUser || learnerUser.role !== 'learner') {
    res.status(400);
    throw new Error('Invalid learner');
  }

  const courseDoc = await Course.findById(course);
  if (!courseDoc) {
    res.status(400);
    throw new Error('Invalid course');
  }

  // Prevent duplicate evaluation for the same learner-course pair
  const existingEval = await Evaluation.findOne({ learner, course });
  if (existingEval) {
    res.status(409);
    throw new Error('Evaluation already exists for this learner and course');
  }

  // Only educator or coordinator can create evaluations
  if (!['educator', 'coordinator'].includes(req.user.role)) {
    res.status(403);
    throw new Error('Not authorized to create evaluations');
  }

  const evaluation = await Evaluation.create({
    learner,
    course,
    educator: req.user._id,
    feedback,
    grade: grade || 'Incomplete',
  });

  res.status(201).json(evaluation);
});

// @desc    Get paginated list of evaluations
// @route   GET /api/v1/evaluations
// @access  Private
exports.getAllEvaluations = asyncHandler(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 25;
  const skip = (page - 1) * limit;

  const total = await Evaluation.countDocuments();
  const evaluations = await Evaluation.find()
    .populate('learner', 'firstName lastName email')
    .populate('course', 'title')
    .populate('educator', 'firstName lastName email')
    .skip(skip)
    .limit(limit);

  res.json({
    count: evaluations.length,
    total,
    page,
    pages: Math.ceil(total / limit),
    data: evaluations,
  });
});

// @desc    Get single evaluation by ID
// @route   GET /api/v1/evaluations/:id
// @access  Private
exports.getEvaluationById = asyncHandler(async (req, res) => {
  const evaluation = await Evaluation.findById(req.params.id)
    .populate('learner', 'firstName lastName email')
    .populate('course', 'title')
    .populate('educator', 'firstName lastName email');

  if (!evaluation) {
    res.status(404);
    throw new Error('Evaluation not found');
  }

  res.json(evaluation);
});

// @desc    Update evaluation
// @route   PATCH /api/v1/evaluations/:id
// @access  Private (owner educator or coordinator)
exports.updateEvaluation = asyncHandler(async (req, res) => {
  const evaluation = await Evaluation.findById(req.params.id);

  if (!evaluation) {
    res.status(404);
    throw new Error('Evaluation not found');
  }

  // Only the educator who created it or coordinator can update
  if (
    evaluation.educator.toString() !== req.user._id.toString() &&
    req.user.role !== 'coordinator'
  ) {
    res.status(403);
    throw new Error('Not authorized to update this evaluation');
  }

  const { feedback, grade } = req.body;

  if (feedback !== undefined) evaluation.feedback = feedback;
  if (grade !== undefined) evaluation.grade = grade;

  const updatedEval = await evaluation.save();
  res.json(updatedEval);
});

// @desc    Delete evaluation
// @route   DELETE /api/v1/evaluations/:id
// @access  Private (owner educator or coordinator)
exports.deleteEvaluation = asyncHandler(async (req, res) => {
  const evaluation = await Evaluation.findById(req.params.id);

  if (!evaluation) {
    res.status(404);
    throw new Error('Evaluation not found');
  }

  if (
    evaluation.educator.toString() !== req.user._id.toString() &&
    req.user.role !== 'coordinator'
  ) {
    res.status(403);
    throw new Error('Not authorized to delete this evaluation');
  }

  await evaluation.remove();
  res.json({ message: 'Evaluation removed successfully' });
});

backend\controllers\quizAttemptController.js
// backend/controllers/quizAttemptController.js
const QuizAttempt = require('../models/QuizAttempt');
const Quiz = require('../models/Quiz');

// ğŸ” Alternate POST controller route for submitting a quiz
exports.submitQuiz = async (req, res) => {
  try {
    const { quizId, answers } = req.body;
    const userId = req.user._id;

    const quiz = await Quiz.findById(quizId);
    if (!quiz) return res.status(404).json({ message: 'Quiz not found' });

    let score = 0;
    quiz.questions.forEach((q, index) => {
      if (
        answers[index] !== undefined &&
        parseInt(answers[index]) === q.correctAnswerIndex
      ) {
        score++;
      }
    });

    const attempt = await QuizAttempt.create({
      quiz: quizId,
      learner: userId,
      answers,
      score,
      totalQuestions: quiz.questions.length,
      attemptedAt: new Date(),
    });

    // Optional: update submissions list in quiz
    await Quiz.findByIdAndUpdate(quizId, {
      $push: { submissions: { learner: userId, score } },
    });

    res.status(201).json({
      message: 'Quiz submitted successfully',
      score,
      correctAnswers: quiz.questions.map((q) => q.correctAnswerIndex),
    });
  } catch (err) {
    res.status(500).json({ message: 'Server error', error: err.message });
  }
};

// ğŸ” Fetch all quiz attempts of the current learner
exports.getMyAttempts = async (req, res) => {
  try {
    const attempts = await QuizAttempt.find({ learner: req.user._id }).populate('quiz', 'title');
    res.json(attempts);
  } catch (err) {
    res.status(500).json({ message: 'Error fetching attempts', error: err.message });
  }
};

backend\middleware\auth.js
const jwt = require('jsonwebtoken');
const asyncHandler = require('express-async-handler');
const User = require('../models/User');


// âœ… Middleware to authenticate users using JWT and protect routes
const protect = asyncHandler(async (req, res, next) => {
  let token;

  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith('Bearer')
  ) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      // âœ… Load user and attach to req.user (excluding password)
      const user = await User.findById(decoded.id).select('-password');
      if (!user) {
        res.status(401);
        throw new Error('User not found');
      }

      // âœ… Prevent inactive educators from accessing routes
      if (user.role === 'educator' && user.isActive === false) {
        return res.status(403).json({
          message: 'Your account is inactive. Please contact your coordinator.',
        });
      }

      // âœ… Attach user to request
      req.user = user;
      next();
    } catch (error) {
      console.error('Authentication error:', error.message);
      res.status(401);
      throw new Error('Not authorized, token failed');
    }
  } else {
    res.status(401);
    throw new Error('Not authorized, no token');
  }
});

// âœ… Middleware to restrict access to specific roles
const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      res.status(401);
      throw new Error('Not authorized, user not found');
    }

    if (!roles.includes(req.user.role)) {
      res.status(403);
      throw new Error(`Access denied. Role '${req.user.role}' not allowed`);
    }

    next();
  };
};

// âœ… Shortcut middleware for specific roles
const isCoordinator = (req, res, next) => {
  if (!req.user || req.user.role !== 'coordinator') {
    return res.status(403).json({ message: 'Access denied. Coordinator only.' });
  }
  next();
};

const isEducator = (req, res, next) => {
  if (!req.user || req.user.role !== 'educator') {
    return res.status(403).json({ message: 'Access denied. Educator only.' });
  }
  next();
};

const isLearner = (req, res, next) => {
  if (!req.user || req.user.role !== 'learner') {
    return res.status(403).json({ message: 'Access denied. Learner only.' });
  }
  next();
};

module.exports = {
  protect,
  authorizeRoles,
  isCoordinator,
  isEducator,
  isLearner,
};


backend\middleware\errorHandler.js
// Centralized error handling middleware for Express
const errorHandler = (err, req, res, next) => {
  // Set default status code
  let statusCode = res.statusCode && res.statusCode !== 200 ? res.statusCode : 500;
  
  // Prepare error response structure
  const response = {
    message: err.message || 'Internal Server Error',
  };

  // Include stack trace only in development for easier debugging
  if (process.env.NODE_ENV === 'development') {
    response.stack = err.stack;
  }

  // Handle specific Mongoose errors or others here if needed
  if (err.name === 'ValidationError') {
    statusCode = 400;
    response.message = Object.values(err.errors).map(e => e.message).join(', ');
  } else if (err.name === 'CastError') {
    statusCode = 400;
    response.message = `Invalid ${err.path}: ${err.value}`;
  } else if (err.code === 11000) {
    statusCode = 400;
    response.message = `Duplicate field value entered: ${JSON.stringify(err.keyValue)}`;
  }

  res.status(statusCode).json(response);
};

module.exports = errorHandler;

backend\middleware\isAdmin.js
// backend/middleware/isAdmin.js

exports.isAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Access denied: Admins only' });
  }
};

backend\middleware\upload.js
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Set storage engine and filename logic
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../uploads/submissions');

    // Ensure upload directory exists
    fs.mkdir(uploadPath, { recursive: true }, (err) => {
      if (err) return cb(err);
      cb(null, uploadPath);
    });
  },
  filename: (req, file, cb) => {
    // Use timestamp + original filename for uniqueness
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
  }
});

// File filter to accept only PDFs (or add more mimetypes if needed)
const fileFilter = (req, file, cb) => {
  const allowedMimeTypes = ['application/pdf'];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only PDF files are allowed!'), false);
  }
};

// Max file size: 10MB (adjust as needed)
const MAX_SIZE = 10 * 1024 * 1024;

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: MAX_SIZE },
});

module.exports = upload;

backend\middleware\uploadCourseImage.js
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Storage configuration for course images
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../uploads/courseImages');

    // Ensure the directory exists
    fs.mkdir(uploadPath, { recursive: true }, (err) => {
      if (err) return cb(err);
      cb(null, uploadPath);
    });
  },
  filename: (req, file, cb) => {
    // Use timestamp + original filename to avoid collisions
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname).toLowerCase();
    cb(null, `course-${uniqueSuffix}${ext}`);
  }
});

// File filter to accept only common image types
const fileFilter = (req, file, cb) => {
  const allowedMimeTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only image files (jpg, jpeg, png, gif) are allowed!'), false);
  }
};

// Max file size: 5MB (adjust as needed)
const MAX_SIZE = 5 * 1024 * 1024;

const uploadCourseImage = multer({
  storage,
  fileFilter,
  limits: { fileSize: MAX_SIZE },
});

module.exports = uploadCourseImage;

backend\models\Assignment.js
const mongoose = require('mongoose');

const assignmentSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, 'Assignment name is required'],
      trim: true,
      maxlength: [100, 'Assignment name cannot exceed 100 characters'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Associated course is required'],
    },
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming Educator is a user with role 'educator'
      required: [true, 'Educator reference is required'],
    },
    dueDate: {
      type: Date,
      required: [true, 'Due date is required'],
      validate: {
        validator: function (value) {
          // Due date must be in the future
          return value > Date.now();
        },
        message: 'Due date must be a future date',
      },
    },
    description: {
      type: String,
      trim: true,
      maxlength: [1000, 'Description cannot exceed 1000 characters'],
    },
    maxScore: {
      type: Number,
      required: [true, 'Maximum score is required'],
      min: [0, 'Maximum score cannot be negative'],
      default: 100,
    },
    createdAt: {
      type: Date,
      default: Date.now,
      immutable: true,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true, // Automatically manages createdAt and updatedAt
  }
);

// Middleware to update updatedAt before save
assignmentSchema.pre('save', function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Assignment', assignmentSchema);

backend\models\Course.js
const mongoose = require('mongoose');

const courseSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: [true, 'Course title is required'],
      trim: true,
      maxlength: [150, 'Course title cannot exceed 150 characters'],
    },
    syllabus: {
      type: String,
      trim: true,
      maxlength: [2000, 'Syllabus cannot exceed 2000 characters'],
    },
    duration: {
      type: String,
      required: [true, 'Course duration is required'],
      trim: true,
      maxlength: [50, 'Duration cannot exceed 50 characters'],
    },
    startDate: {
      type: Date,
      required: [true, 'Course start date is required'],
    },
    endDate: {
      type: Date,
      required: [true, 'Course end date is required'],
      validate: {
        validator: function (value) {
          return !this.startDate || value > this.startDate;
        },
        message: 'End date must be after start date',
      },
    },
    category: {
      type: String,
      enum: [
        'Mathematics',
        'Physics',
        'Chemistry',
        'Biology',
        'Engineering',
        'Science and Technology',
        'Programming and Web Development',
        'Commerce and Management',
      ],
      required: [true, 'Course category is required'],
    },
    venue: {
      type: String,
      enum: ['Online', 'Face to Face', 'Offline'],
      required: [true, 'Venue is required'],
    },
    medium: {
      type: String,
      enum: ['English', 'Tamil', 'Sinhala'],
      required: [true, 'Medium of instruction is required'],
    },
    fee: {
      type: Number,
      min: [0, 'Fee cannot be negative'],
      required: [true, 'Course fee is required'],
    },
    classTimes: [
      {
        day: {
          type: String,
          enum: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
          required: true,
        },
        startTime: {
          type: String,
          required: true,
          validate: {
            validator: (value) => /^([01]\d|2[0-3]):([0-5]\d)$/.test(value),
            message: 'Invalid start time format (HH:mm)',
          },
        },
        endTime: {
          type: String,
          required: true,
          validate: {
            validator: (value) => /^([01]\d|2[0-3]):([0-5]\d)$/.test(value),
            message: 'Invalid end time format (HH:mm)',
          },
        },
      },
    ],
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Educator is required'],
    },
    courseImage: {
      type: String, // path or URL
    },
    createdAt: {
      type: Date,
      default: Date.now,
      immutable: true,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

courseSchema.pre('save', function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Course', courseSchema);

backend\models\DoubtSession.js
const mongoose = require('mongoose');

const doubtSessionSchema = new mongoose.Schema(
  {
    topic: {
      type: String,
      required: [true, 'Doubt session topic is required'],
      trim: true,
      maxlength: [200, 'Topic cannot exceed 200 characters'],
    },
    description: {
      type: String,
      trim: true,
      maxlength: [1000, 'Description cannot exceed 1000 characters'],
    },
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming educator is a User with role 'educator'
      required: [true, 'Educator reference is required'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Associated course is required'],
    },
    scheduledDate: {
      type: Date,
      required: [true, 'Scheduled date is required'],
      validate: {
        validator: function (value) {
          // Scheduled date must be in the future
          return value > Date.now();
        },
        message: 'Scheduled date must be a future date',
      },
    },
    durationMinutes: {
      type: Number,
      required: [true, 'Duration is required'],
      min: [1, 'Duration must be at least 1 minute'],
      max: [180, 'Duration cannot exceed 180 minutes'],
    },
    link: {
      type: String,
      trim: true,
      validate: {
        validator: function (v) {
          // Simple URL validation regex
          return !v || /^(https?:\/\/)?([\w.-]+)+(:\d+)?(\/([\w/_.]*)?)?$/.test(v);
        },
        message: 'Invalid URL format',
      },
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true, // createdAt, updatedAt
  }
);

module.exports = mongoose.model('DoubtSession', doubtSessionSchema);

backend\models\Educator.js
const mongoose = require('mongoose');

const educatorSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Associated user is required'],
      unique: true,
    },
    qualifications: {
      type: String,
      trim: true,
      maxlength: [500, 'Qualifications cannot exceed 500 characters'],
    },
    experienceYears: {
      type: Number,
      min: [0, 'Experience cannot be negative'],
      max: [50, 'Experience seems too high'],
      default: 0,
    },
    bio: {
      type: String,
      trim: true,
      maxlength: [1000, 'Biography cannot exceed 1000 characters'],
    },
    avatarUrl: {
      type: String,
      trim: true,
      validate: {
        validator: function (v) {
          // Simple URL validation, allow empty
          return !v || /^(https?:\/\/)?([\w.-]+)+(:\d+)?(\/([\w/_.]*)?)?$/.test(v);
        },
        message: 'Invalid URL format for avatar',
      },
    },
    phone: {
      type: String,
      trim: true,
      validate: {
        validator: function (v) {
          // Basic phone validation: digits, spaces, +, -, ()
          return !v || /^[\d+\-\s\(\)]+$/.test(v);
        },
        message: 'Invalid phone number format',
      },
    },
    address: {
      type: String,
      trim: true,
      maxlength: [500, 'Address cannot exceed 500 characters'],
    },
    country: {
      type: String,
      trim: true,
      maxlength: [100, 'Country name too long'],
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model('Educator', educatorSchema);

backend\models\Enrollment.js
const mongoose = require('mongoose');

const enrollmentSchema = new mongoose.Schema(
  {
    learner: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming learners are Users with role 'learner'
      required: [true, 'Learner reference is required'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Course reference is required'],
    },
    enrollmentDate: {
      type: Date,
      default: Date.now,
      immutable: true,
    },
    status: {
      type: String,
      enum: ['active', 'completed', 'dropped', 'pending'],
      default: 'active',
      required: true,
    },
    progressPercentage: {
      type: Number,
      min: [0, 'Progress cannot be less than 0%'],
      max: [100, 'Progress cannot exceed 100%'],
      default: 0,
    },
  },
  {
    timestamps: true, // createdAt and updatedAt
  }
);

// Add a unique compound index to prevent duplicate enrollments
enrollmentSchema.index({ learner: 1, course: 1 }, { unique: true });

module.exports = mongoose.model('Enrollment', enrollmentSchema);

backend\models\Evaluation.js
const mongoose = require('mongoose');

const evaluationSchema = new mongoose.Schema(
  {
    learner: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming User role 'learner'
      required: [true, 'Learner reference is required'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Course reference is required'],
    },
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming User role 'educator'
      required: [true, 'Educator reference is required'],
    },
    feedback: {
      type: String,
      required: [true, 'Feedback is required'],
      trim: true,
      maxlength: [2000, 'Feedback cannot exceed 2000 characters'],
    },
    grade: {
      type: String,
      enum: ['A', 'B', 'C', 'D', 'E', 'F', 'Incomplete', 'Pass', 'Fail'], // Customize grading scale as needed
      default: 'Incomplete',
    },
    createdAt: {
      type: Date,
      default: Date.now,
      immutable: true,
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

// Unique compound index to prevent multiple evaluations for the same learner-course pair
evaluationSchema.index({ learner: 1, course: 1 }, { unique: true });

// Middleware to update updatedAt before save
evaluationSchema.pre('save', function (next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Evaluation', evaluationSchema);

backend\models\ForumPost.js
const mongoose = require('mongoose');

const forumPostSchema = new mongoose.Schema(
  {
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Author is required'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Associated course is required'],
    },
    content: {
      type: String,
      required: [true, 'Post content is required'],
      trim: true,
      maxlength: [3000, 'Content cannot exceed 3000 characters'],
    },
    parentPost: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'ForumPost',
      default: null, // Null for top-level posts; set for replies
    },
    // Optionally, add a field to track if post is edited
    isEdited: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true, // createdAt and updatedAt
  }
);

// Index to improve lookup by course and parentPost
forumPostSchema.index({ course: 1, parentPost: 1, createdAt: -1 });

module.exports = mongoose.model('ForumPost', forumPostSchema);

backend\models\Quiz.js
const mongoose = require('mongoose');

const questionSchema = new mongoose.Schema(
  {
    questionText: {
      type: String,
      required: [true, 'Question text is required'],
      trim: true,
      maxlength: [1000, 'Question text cannot exceed 1000 characters'],
    },
    options: {
      type: [String],
      validate: {
        validator: function (v) {
          return v.length >= 2;
        },
        message: 'Each question must have at least two options',
      },
      required: [true, 'Options are required'],
    },
    correctAnswerIndex: {
      type: Number,
      required: [true, 'Correct answer index is required'],
      validate: {
        validator: function (v) {
          return this.options && v >= 0 && v < this.options.length;
        },
        message: 'Correct answer index must be within options range',
      },
    },
  },
  { _id: false }
);

const quizSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: [true, 'Quiz title is required'],
      trim: true,
      maxlength: [150, 'Quiz title cannot exceed 150 characters'],
    },
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Associated course is required'],
    },
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Educator reference is required'],
    },
    questions: {
      type: [questionSchema],
      validate: {
        validator: function (v) {
          return v.length > 0;
        },
        message: 'Quiz must contain at least one question',
      },
      required: [true, 'Questions are required'],
    },
    durationMinutes: {
      type: Number,
      min: [1, 'Duration must be at least 1 minute'],
      max: [180, 'Duration cannot exceed 180 minutes'],
      default: 30,
    },
    published: {
    type: Boolean,
    default: false,
  },
    submissions: [
      {
        learner: {
          type: mongoose.Schema.Types.ObjectId,
          ref: 'User',
        },
        answers: {
          type: [Number],
          validate: {
            validator: function (v) {
              return v.length === this.questions.length;
            },
            message: 'All questions must be answered',
          },
        },
        score: {
          type: Number,
          default: 0,
        },
        submittedAt: {
          type: Date,
          default: Date.now,
        },
      },
    ],
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model('Quiz', quizSchema);

backend\models\QuizAttempt.js
// backend/models/QuizAttempt.js
const mongoose = require('mongoose');
const QuizAttempt = require('../models/QuizAttempt');


const quizAttemptSchema = new mongoose.Schema({
  learner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  quiz: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Quiz',
    required: true,
  },
  answers: [
    {
      questionIndex: Number,
      selectedOption: Number,
    },
  ],
  score: {
    type: Number,
    required: true,
  },
  totalQuestions: {
    type: Number,
    required: true,
  },
  attemptedAt: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model('QuizAttempt', quizAttemptSchema);

backend\models\StudyPlan.js
const mongoose = require('mongoose');

const studyPlanSchema = new mongoose.Schema(
  {
    course: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Course',
      required: [true, 'Associated course is required'],
    },
    educator: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming educator is a User with role 'educator'
      required: [true, 'Educator reference is required'],
    },
    title: {
      type: String,
      required: [true, 'Study plan title is required'],
      trim: true,
      maxlength: [150, 'Title cannot exceed 150 characters'],
    },
    description: {
      type: String,
      trim: true,
      maxlength: [1000, 'Description cannot exceed 1000 characters'],
    },
    schedule: [
      {
        date: {
          type: Date,
          required: [true, 'Schedule date is required'],
        },
        topic: {
          type: String,
          required: [true, 'Topic is required'],
          trim: true,
          maxlength: [300, 'Topic cannot exceed 300 characters'],
        },
        notesUrl: {
          type: String,
          trim: true,
          validate: {
            validator: function (v) {
              return !v || /^(https?:\/\/)?([\w.-]+)+(:\d+)?(\/([\w/_.]*)?)?$/.test(v);
            },
            message: 'Invalid URL format',
          },
        },
      },
    ],
    materials: [
      {
        fileName: {
          type: String,
          required: true,
        },
        fileUrl: {
          type: String,
          required: true,
        },
      },
    ],
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model('StudyPlan', studyPlanSchema);

backend\models\Submission.js
const mongoose = require('mongoose');

const submissionSchema = new mongoose.Schema(
  {
    assignment: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Assignment',
      required: [true, 'Assignment reference is required'],
    },
    learner: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // Assuming User with role 'learner'
      required: [true, 'Learner reference is required'],
    },
    submittedAt: {
      type: Date,
      default: Date.now,
      immutable: true,
    },
    fileUrl: {
      type: String,
      required: [true, 'Submission file URL/path is required'],
      trim: true,
    },
    fileName: {
      type: String,
      trim: true,
    },
    status: {
      type: String,
      enum: ['submitted', 'graded', 'late', 'resubmitted'],
      default: 'submitted',
    },
    grade: {
      type: Number,
      min: [0, 'Grade cannot be negative'],
      max: [100, 'Grade cannot exceed 100'],
    },
    feedback: {
      type: String,
      trim: true,
      maxlength: [2000, 'Feedback cannot exceed 2000 characters'],
    },
  },
  {
    timestamps: true, // createdAt, updatedAt
  }
);

// Compound index to prevent multiple submissions by the same learner for the same assignment (optional)
// submissionSchema.index({ assignment: 1, learner: 1 }, { unique: true });

module.exports = mongoose.model('Submission', submissionSchema);

backend\models\User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema(
  {
    firstName: {
      type: String,
      required: [true, 'First name is required'],
      trim: true,
      maxlength: [50, 'First name cannot exceed 50 characters'],
    },
    lastName: {
      type: String,
      required: [true, 'Last name is required'],
      trim: true,
      maxlength: [50, 'Last name cannot exceed 50 characters'],
    },
    email: {
      type: String,
      required: [true, 'Email is required'],
      unique: true,
      lowercase: true,
      trim: true,
      match: [/\S+@\S+\.\S+/, 'Please use a valid email address'],
    },
    password: {
      type: String,
      required: [true, 'Password is required'],
      minlength: [6, 'Password must be at least 6 characters'],
      select: false, // Exclude password from query results by default
    },
    dob: {
      type: Date,
      required: [true, 'Date of birth is required'],
    },
    sex: {
      type: String,
      enum: ['Male', 'Female', 'Other'],
      required: [true, 'Sex is required'],
    },
    phone: {
      type: String,
      trim: true,
      validate: {
        validator: function (v) {
          return !v || /^[\d+\-\s\(\)]+$/.test(v);
        },
        message: 'Invalid phone number format',
      },
    },
    address: {
      type: String,
      trim: true,
      maxlength: [500, 'Address cannot exceed 500 characters'],
    },
    country: {
      type: String,
      trim: true,
      maxlength: [100, 'Country name too long'],
    },
    role: {
      type: String,
      enum: ['coordinator', 'educator', 'learner'],
      default: 'learner',
      required: true,
    },
    avatarUrl: {
      type: String,
      trim: true,
      validate: {
        validator: function (v) {
          return !v || /^(https?:\/\/)?([\w.-]+)+(:\d+)?(\/([\w/_.]*)?)?$/.test(v);
        },
        message: 'Invalid URL format for avatar',
      },
    },
    // Add this inside the userSchema definition
    isActive: {
    type: Boolean,
    default: true, // educators are active by default
    },

  },
  {
    timestamps: true,
  }
);

// Password hashing middleware before saving user
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    return next();
  }
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (err) {
    next(err);
  }
});

// Method to compare entered password with hashed password
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

backend\routes\AdminRoute.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');
const Assignment = require('../models/Assignment');
const Course = require('../models/Course');
const { protect, authorizeRoles } = require('../middleware/auth');

// Create Assignment
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const { name, course, dueDate, description, maxScore } = req.body;
    const userId = req.user._id;
    const role = req.user.role;

    if (!name || !course || !dueDate) {
      res.status(400);
      throw new Error('Name, course, and due date are required');
    }

    const courseDoc = await Course.findById(course);
    if (!courseDoc) {
      res.status(404);
      throw new Error('Course not found');
    }

    if (role === 'educator' && courseDoc.educator.toString() !== userId.toString()) {
      res.status(403);
      throw new Error('Not authorized to create assignment for this course');
    }

    const assignment = await Assignment.create({
      name,
      course,
      educator: userId,
      dueDate,
      description,
      maxScore,
    });

    res.status(201).json(assignment);
  })
);

// Get All Assignments
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const filter = {};
    if (req.query.course) {
      filter.course = req.query.course;
    }

    const assignments = await Assignment.find(filter)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email')
      .sort({ dueDate: 1 });

    res.json(assignments);
  })
);

// Get Assignment by ID
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email');

    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    res.json(assignment);
  })
);

// Update Assignment
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id);
    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    const userId = req.user._id;
    const role = req.user.role;

    if (assignment.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to update this assignment');
    }

    const { name, dueDate, description, maxScore } = req.body;

    if (name !== undefined) assignment.name = name;
    if (dueDate !== undefined) assignment.dueDate = dueDate;
    if (description !== undefined) assignment.description = description;
    if (maxScore !== undefined) assignment.maxScore = maxScore;

    const updatedAssignment = await assignment.save();
    res.json(updatedAssignment);
  })
);

// Delete Assignment
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id);
    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    const userId = req.user._id;
    const role = req.user.role;

    if (assignment.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to delete this assignment');
    }

    await assignment.remove();
    res.json({ message: 'Assignment removed successfully' });
  })
);

module.exports = router;

backend\routes\assignmentRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');
const Assignment = require('../models/Assignment');
const Course = require('../models/Course');
const { protect, authorizeRoles } = require('../middleware/auth');

// @route   POST /api/v1/assignments
// @desc    Create assignment
// @access  Private (educator, coordinator)
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const { name, course, dueDate, description, maxScore } = req.body;
    const userId = req.user._id;
    const role = req.user.role;

    if (!name || !course || !dueDate) {
      res.status(400);
      throw new Error('Name, course, and due date are required');
    }

    const courseDoc = await Course.findById(course);
    if (!courseDoc) {
      res.status(404);
      throw new Error('Course not found');
    }

    // Authorization: Educators can only create assignments for their own courses
    if (role === 'educator' && courseDoc.educator.toString() !== userId.toString()) {
      res.status(403);
      throw new Error('Not authorized to create assignment for this course');
    }

    const assignment = await Assignment.create({
      name,
      course,
      educator: userId,
      dueDate,
      description,
      maxScore,
    });

    res.status(201).json(assignment);
  })
);

// @route   GET /api/v1/assignments
// @desc    Get all assignments (optionally filtered by course)
// @access  Private
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const filter = {};
    if (req.query.course) {
      filter.course = req.query.course;
    }

    const assignments = await Assignment.find(filter)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email')
      .sort({ dueDate: 1 });

    res.json(assignments);
  })
);

// @route   GET /api/v1/assignments/:id
// @desc    Get assignment by ID
// @access  Private
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email');

    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    res.json(assignment);
  })
);

// @route   PATCH /api/v1/assignments/:id
// @desc    Update assignment
// @access  Private
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id);
    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    const userId = req.user._id;
    const role = req.user.role;

    if (assignment.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to update this assignment');
    }

    const { name, dueDate, description, maxScore } = req.body;

    if (name !== undefined) assignment.name = name;
    if (dueDate !== undefined) assignment.dueDate = dueDate;
    if (description !== undefined) assignment.description = description;
    if (maxScore !== undefined) assignment.maxScore = maxScore;

    const updated = await assignment.save();
    res.json(updated);
  })
);

// @route   DELETE /api/v1/assignments/:id
// @desc    Delete assignment
// @access  Private
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const assignment = await Assignment.findById(req.params.id);
    if (!assignment) {
      res.status(404);
      throw new Error('Assignment not found');
    }

    const userId = req.user._id;
    const role = req.user.role;

    if (assignment.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to delete this assignment');
    }

    await assignment.remove();
    res.json({ message: 'Assignment removed successfully' });
  })
);

module.exports = router;

backend\routes\avatarUploadRoute.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const { protect } = require('../middleware/auth');
const User = require('../models/User');
const fs = require('fs');

// Setup storage engine with Multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../uploads/avatars');
    fs.mkdirSync(uploadPath, { recursive: true }); // Ensure directory exists
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    // Unique filename: userId + timestamp + extension
    const ext = path.extname(file.originalname).toLowerCase();
    cb(null, `${req.user._id}-${Date.now()}${ext}`);
  },
});

// File filter: only accept image files (jpeg, jpg, png, gif)
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only jpeg, jpg, png, and gif are allowed.'));
  }
};

// Limit file size to 5 MB
const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 },
}).single('avatar');

// @route   POST /api/v1/avatar/upload
// @desc    Upload or update user avatar
// @access  Private
router.post('/upload', protect, (req, res) => {
  upload(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ message: err.message });
    }

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    try {
      // Delete old avatar if exists
      const user = await User.findById(req.user._id);
      if (user.avatarUrl) {
        const oldPath = path.join(__dirname, '../', user.avatarUrl);
        fs.unlink(oldPath, (unlinkErr) => {
          // Ignore errors here, just log if any
          if (unlinkErr) console.error('Failed to delete old avatar:', unlinkErr);
        });
      }

      // Save new avatar path in user document (relative path)
      user.avatarUrl = `uploads/avatars/${req.file.filename}`;
      await user.save();

      res.json({ message: 'Avatar uploaded successfully', avatarUrl: user.avatarUrl });
    } catch (error) {
      console.error('Error updating avatar:', error);
      res.status(500).json({ message: 'Server error while updating avatar' });
    }
  });
});

module.exports = router;

backend\routes\courseRoutes.js
const express = require('express');
const router = express.Router();
const Course = require('../models/Course');

const {
  createCourse,
  getCourses,
  getCourseById,
  updateCourse,
  deleteCourse,
  getCoursesWithStudentsAndMarks, // âœ… new controller for advanced export
} = require('../controllers/courseController');

const { protect, authorizeRoles } = require('../middleware/auth');
const uploadCourseImage = require('../middleware/uploadCourseImage');
const { getCoursesWithStudents } = require('../controllers/courseController');


// Route prefix: /api/v1/courses

// âœ… NEW: Get all courses with educator and enrolled student marks (coordinator and admin only)
router.get(
  '/with-students',
  protect,
  authorizeRoles('coordinator', 'admin'),
  getCoursesWithStudentsAndMarks
);

// âœ… NEW: Get all courses with enrolled learners only (no marks)
router.get(
  '/with-students-simple',
  protect,
  authorizeRoles('coordinator'),
  getCoursesWithStudents
);

// âœ… Educator-only: Get courses assigned to the logged-in educator
router.get(
  '/my',
  protect,
  authorizeRoles('educator'),
  async (req, res) => {
    try {
      const educatorId = req.user._id;
      const courses = await Course.find({ educator: educatorId }).populate('educator', 'firstName lastName email');
      res.json(courses);
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: 'Failed to load educator courses' });
    }
  }
);

// Create a new course (only coordinators)
router.post(
  '/',
  protect,
  authorizeRoles('coordinator'),
  uploadCourseImage.single('courseImage'),
  createCourse
);

// Get courses with filtering, pagination, sorting (all authenticated users)
router.get('/', protect, getCourses);

// Get a single course by ID (authenticated users)
router.get('/:id', protect, getCourseById);

// Update a course (only coordinators)
router.patch(
  '/:id',
  protect,
  authorizeRoles('coordinator'),
  uploadCourseImage.single('courseImage'),
  updateCourse
);

// Delete a course (only coordinators)
router.delete('/:id', protect, authorizeRoles('coordinator'), deleteCourse);

module.exports = router;

backend\routes\dashboardRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const Course = require('../models/Course');
const Assignment = require('../models/Assignment');
const User = require('../models/User');
const Enrollment = require('../models/Enrollment');
const Submission = require('../models/Submission');

const { protect, authorizeRoles } = require('../middleware/auth');

// @route   GET /api/v1/dashboard/metrics
// @desc    Dashboard summary metrics for coordinator & educator
router.get(
  '/metrics',
  protect,
  authorizeRoles('coordinator', 'educator'),
  asyncHandler(async (req, res) => {
    const role = req.user.role;
    const userId = req.user._id;

    let coursesCount = 0;
    let assignmentsCount = 0;
    let educatorsCount = 0;
    let learnersCount = 0;
    let enrollmentsCount = 0;
    let submissionsCount = 0;
    let gradedSubmissionsCount = 0;
    let averageGrade = 0;

    if (role === 'coordinator') {
      // Coordinator sees global stats
      coursesCount = await Course.countDocuments();
      assignmentsCount = await Assignment.countDocuments();
      educatorsCount = await User.countDocuments({ role: 'educator' });
      learnersCount = await User.countDocuments({ role: 'learner' });
      enrollmentsCount = await Enrollment.countDocuments();
      submissionsCount = await Submission.countDocuments();
      gradedSubmissionsCount = await Submission.countDocuments({ grade: { $ne: null } });

      const gradedSubs = await Submission.find({ grade: { $ne: null } });
      if (gradedSubs.length > 0) {
        averageGrade = gradedSubs.reduce((sum, s) => sum + parseFloat(s.grade), 0) / gradedSubs.length;
      }
    } else if (role === 'educator') {
      // Educator-specific stats
      coursesCount = await Course.countDocuments({ educator: userId });
      assignmentsCount = await Assignment.countDocuments({ educator: userId });
      educatorsCount = 1;

      const courseIds = await Course.find({ educator: userId }).distinct('_id');
      learnersCount = await Enrollment.countDocuments({ course: { $in: courseIds } });
      enrollmentsCount = learnersCount;

      const assignmentIds = await Assignment.find({ educator: userId }).distinct('_id');
      const submissions = await Submission.find({ assignment: { $in: assignmentIds } });

      submissionsCount = submissions.length;
      gradedSubmissionsCount = submissions.filter(s => s.grade !== undefined && s.grade !== null).length;

      const gradedOnly = submissions.filter(s => s.grade !== undefined && s.grade !== null);
      if (gradedOnly.length > 0) {
        averageGrade = gradedOnly.reduce((sum, s) => sum + parseFloat(s.grade), 0) / gradedOnly.length;
      }
    } else {
      return res.status(403).json({ message: 'Unauthorized role' });
    }

    res.status(200).json({
      coursesCount,
      assignmentsCount,
      educatorsCount,
      learnersCount,
      enrollmentsCount,
      submissionsCount,
      gradedSubmissionsCount,
      averageGrade: averageGrade.toFixed(2),
    });
  })
);

module.exports = router;

backend\routes\doubtRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const DoubtSession = require('../models/DoubtSession');
const { protect, authorizeRoles } = require('../middleware/auth');

// @route   POST /api/v1/doubts
// @desc    Create a new doubt session
// @access  Private (educator, coordinator)
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const { topic, description, course, scheduledDate, durationMinutes, link } = req.body;

    // Basic validation
    if (!topic || !course || !scheduledDate || !durationMinutes) {
      res.status(400);
      throw new Error('Topic, course, scheduledDate, and durationMinutes are required');
    }

    const newSession = await DoubtSession.create({
      topic,
      description,
      course,
      scheduledDate,
      durationMinutes,
      link,
      educator: req.user._id,
    });

    res.status(201).json(newSession);
  })
);

// @route   GET /api/v1/doubts
// @desc    Get all doubt sessions
// @access  Private (all authenticated users)
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const sessions = await DoubtSession.find()
      .populate('educator', 'firstName lastName email')
      .populate('course', 'title')
      .sort({ scheduledDate: 1 });

    res.json(sessions);
  })
);

// @route   GET /api/v1/doubts/:id
// @desc    Get doubt session by ID
// @access  Private
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const session = await DoubtSession.findById(req.params.id)
      .populate('educator', 'firstName lastName email')
      .populate('course', 'title');

    if (!session) {
      res.status(404);
      throw new Error('Doubt session not found');
    }

    res.json(session);
  })
);

// @route   PATCH /api/v1/doubts/:id
// @desc    Update a doubt session
// @access  Private (owner educator or coordinator)
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const session = await DoubtSession.findById(req.params.id);

    if (!session) {
      res.status(404);
      throw new Error('Doubt session not found');
    }

    // Authorization: only owner educator or coordinator
    const role = req.user.role;
    const userId = req.user._id;
    if (session.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to update this session');
    }

    const {
      topic,
      description,
      course,
      scheduledDate,
      durationMinutes,
      link,
      isActive,
    } = req.body;

    if (topic !== undefined) session.topic = topic;
    if (description !== undefined) session.description = description;
    if (course !== undefined) session.course = course;
    if (scheduledDate !== undefined) session.scheduledDate = scheduledDate;
    if (durationMinutes !== undefined) session.durationMinutes = durationMinutes;
    if (link !== undefined) session.link = link;
    if (isActive !== undefined) session.isActive = isActive;

    const updatedSession = await session.save();
    res.json(updatedSession);
  })
);

// @route   DELETE /api/v1/doubts/:id
// @desc    Delete a doubt session
// @access  Private (owner educator or coordinator)
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const session = await DoubtSession.findById(req.params.id);

    if (!session) {
      res.status(404);
      throw new Error('Doubt session not found');
    }

    const role = req.user.role;
    const userId = req.user._id;
    if (session.educator.toString() !== userId.toString() && role !== 'coordinator') {
      res.status(403);
      throw new Error('Not authorized to delete this session');
    }

    await session.remove();
    res.json({ message: 'Doubt session deleted successfully' });
  })
);

module.exports = router;

backend\routes\educatorRoutes.js
// backend/routes/educatorRoutes.js

const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const User = require('../models/User');
const { protect, authorizeRoles } = require('../middleware/auth');

const {
  getAllEducators,
  deleteEducator,
  toggleEducatorStatus, // âœ… Imported
} = require('../controllers/educatorController');

/**
 * @route   GET /api/v1/educators/me
 * @desc    Get current logged-in educator profile
 * @access  Private (educator)
 */
router.get(
  '/me',
  protect,
  authorizeRoles('educator'),
  asyncHandler(async (req, res) => {
    const educator = await User.findById(req.user._id).select('-password');
    if (!educator || educator.role !== 'educator') {
      res.status(404);
      throw new Error('Educator not found');
    }
    res.json(educator);
  })
);

/**
 * @route   PATCH /api/v1/educators/profile
 * @desc    Update current educator profile
 * @access  Private (educator)
 */
router.patch(
  '/profile',
  protect,
  authorizeRoles('educator'),
  asyncHandler(async (req, res) => {
    const educator = await User.findById(req.user._id);

    if (!educator || educator.role !== 'educator') {
      res.status(404);
      throw new Error('Educator not found');
    }

    const {
      firstName,
      lastName,
      phone,
      address,
      country,
      avatarUrl,
      dob,
      sex,
    } = req.body;

    if (firstName !== undefined) educator.firstName = firstName;
    if (lastName !== undefined) educator.lastName = lastName;
    if (phone !== undefined) educator.phone = phone;
    if (address !== undefined) educator.address = address;
    if (country !== undefined) educator.country = country;
    if (avatarUrl !== undefined) educator.avatarUrl = avatarUrl;
    if (dob !== undefined) educator.dob = dob;
    if (sex !== undefined) educator.sex = sex;

    const updatedEducator = await educator.save();
    res.json(updatedEducator);
  })
);

/**
 * @route   GET /api/v1/educators
 * @desc    Get all educators - visible to coordinator only
 * @access  Private (coordinator)
 */
router.get(
  '/',
  protect,
  authorizeRoles('coordinator'),
  asyncHandler(async (req, res) => {
    const educators = await User.find({ role: 'educator' })
      .select('-password')
      .sort({ createdAt: -1 });

    res.json(educators);
  })
);

/**
 * @route   PUT /api/v1/educators/toggle-status/:id
 * @desc    Toggle educator active/inactive status
 * @access  Private (coordinator)
 */
router.put(
  '/toggle-status/:id',
  protect,
  authorizeRoles('coordinator'),
  toggleEducatorStatus // âœ… New route
);

module.exports = router;

backend\routes\enrollmentRoutes.js
const express = require('express');
const router = express.Router();
const {
  enrollInCourse,
  getAllEnrollments,
  getEnrollmentById,
  updateEnrollment,
  deleteEnrollment,
  getMyEnrollmentHistory,
  generateReceiptPDF,
  getLearnersWithEnrollments // âœ… added controller
} = require('../controllers/enrollmentController');

const asyncHandler = require('express-async-handler');
const Enrollment = require('../models/Enrollment');
const Course = require('../models/Course');
const { protect, authorizeRoles } = require('../middleware/auth');

// âœ… Enroll a learner
router.post(
  '/',
  protect,
  authorizeRoles('learner'),
  asyncHandler(async (req, res) => {
    const learnerId = req.user._id;
    const { course } = req.body;

    if (!course) {
      res.status(400);
      throw new Error('Course ID is required');
    }

    const courseDoc = await Course.findById(course);
    if (!courseDoc) {
      res.status(404);
      throw new Error('Course not found');
    }

    const existingEnrollment = await Enrollment.findOne({ learner: learnerId, course });
    if (existingEnrollment) {
      res.status(400);
      throw new Error('You are already enrolled in this course');
    }

    const enrollment = await Enrollment.create({
      learner: learnerId,
      course,
      status: 'active',
      enrollmentDate: new Date(),
      progressPercentage: 0,
    });

    res.status(201).json(enrollment);
  })
);

// âœ… Get all enrollments
router.get(
  '/',
  protect,
  authorizeRoles('coordinator', 'educator', 'learner'),
  asyncHandler(async (req, res) => {
    let filter = {};
    const role = req.user.role;
    const userId = req.user._id;

    if (role === 'learner') {
      filter.learner = userId;
    } else if (role === 'educator') {
      const courses = await Course.find({ educator: userId }).select('_id');
      filter.course = { $in: courses.map((c) => c._id) };
    }

    const enrollments = await Enrollment.find(filter)
      .populate('learner', 'firstName lastName email')
      .populate('course', 'title category venue medium duration startDate endDate')
      .sort({ enrollmentDate: -1 });

    res.json(enrollments);
  })
);

// âœ… Get learners with their enrolled courses (NEW)
router.get(
  '/by-learner', // âœ… NEW ROUTE
  protect,
  authorizeRoles('coordinator'),
  getLearnersWithEnrollments
);

// âœ… Get enrollment by ID
router.get(
  '/:id',
  protect,
  authorizeRoles('coordinator', 'educator', 'learner'),
  asyncHandler(async (req, res) => {
    const enrollment = await Enrollment.findById(req.params.id)
      .populate('learner', 'firstName lastName email')
      .populate('course', 'title category educator');

    if (!enrollment) {
      res.status(404);
      throw new Error('Enrollment not found');
    }

    const userId = req.user._id.toString();
    const role = req.user.role;
    const isEducatorOfCourse =
      enrollment.course.educator && enrollment.course.educator.toString() === userId;

    if (
      role === 'learner' &&
      enrollment.learner._id.toString() !== userId &&
      !isEducatorOfCourse &&
      role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to view this enrollment');
    }

    res.json(enrollment);
  })
);

// âœ… Update enrollment
router.patch(
  '/:id',
  protect,
  authorizeRoles('learner', 'coordinator'),
  asyncHandler(async (req, res) => {
    const enrollment = await Enrollment.findById(req.params.id);

    if (!enrollment) {
      res.status(404);
      throw new Error('Enrollment not found');
    }

    if (
      req.user.role === 'learner' &&
      enrollment.learner.toString() !== req.user._id.toString()
    ) {
      res.status(403);
      throw new Error('Not authorized to update this enrollment');
    }

    const { status, progressPercentage } = req.body;

    if (status !== undefined) enrollment.status = status;
    if (progressPercentage !== undefined) {
      if (progressPercentage < 0 || progressPercentage > 100) {
        res.status(400);
        throw new Error('Progress percentage must be between 0 and 100');
      }
      enrollment.progressPercentage = progressPercentage;
    }

    const updated = await enrollment.save();
    res.json(updated);
  })
);

// âœ… Delete enrollment
router.delete(
  '/:id',
  protect,
  authorizeRoles('learner', 'coordinator'),
  asyncHandler(async (req, res) => {
    const enrollment = await Enrollment.findById(req.params.id).populate('course');

    if (!enrollment) {
      res.status(404);
      throw new Error('Enrollment not found');
    }

    const userId = req.user._id.toString();

    if (req.user.role === 'learner') {
      if (enrollment.learner.toString() !== userId) {
        res.status(403);
        throw new Error('Not authorized to delete this enrollment');
      }

      const courseStartDate = new Date(enrollment.course.startDate);
      const today = new Date();
      const diffDays = (today - courseStartDate) / (1000 * 60 * 60 * 24);

      if (diffDays > 7) {
        res.status(403);
        throw new Error('Unenrollment period expired. You can only unenroll within 7 days after the course starts.');
      }
    }

    await enrollment.deleteOne();
    res.json({ message: 'Enrollment deleted successfully' });
  })
);

module.exports = router;

backend\routes\evaluationRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const {
  createEvaluation,
  getAllEvaluations,
  getEvaluationById,
  updateEvaluation,
  deleteEvaluation,
} = require('../controllers/evaluationController');

const { protect, authorizeRoles } = require('../middleware/auth');

// Route prefix: /api/v1/evaluations

// Create a new evaluation (educator or coordinator only)
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(createEvaluation)
);

// Get paginated list of evaluations (authenticated users)
router.get(
  '/',
  protect,
  asyncHandler(getAllEvaluations)
);

// Get single evaluation by ID (authenticated users)
router.get(
  '/:id',
  protect,
  asyncHandler(getEvaluationById)
);

// Update evaluation (only creator educator or coordinator)
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(updateEvaluation)
);

// Delete evaluation (only creator educator or coordinator)
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(deleteEvaluation)
);

module.exports = router;

backend\routes\footerRoutes.js
// backend/routes/footerRoutes.js
const express = require('express');
const router = express.Router();

// Optional: Secure this route only for logged-in users if needed

router.get('/quick-links', (req, res) => {
  res.json([
    { name: 'Home', to: '/' },
    { name: 'About', to: '/about' },
    { name: 'Contact', to: '/contact' },
    { name: 'Privacy Policy', to: '/privacy-policy' }
  ]);
});

module.exports = router;

backend\routes\forumRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const ForumPost = require('../models/ForumPost');
const { protect, authorizeRoles } = require('../middleware/auth');

// @route   POST /api/v1/forum
// @desc    Create a new forum post or reply
// @access  Private (all authenticated users)
router.post(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const { content, course, parentPost } = req.body;

    if (!content || !course) {
      res.status(400);
      throw new Error('Content and course are required');
    }

    // Optionally verify course exists if needed (can be added here)

    const newPost = await ForumPost.create({
      author: req.user._id,
      course,
      content,
      parentPost: parentPost || null,
    });

    res.status(201).json(newPost);
  })
);

// @route   GET /api/v1/forum
// @desc    Get all forum posts optionally filtered by course
// @access  Private (all authenticated users)
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const { course } = req.query;

    const filter = {};
    if (course) {
      filter.course = course;
    }

    // Fetch posts sorted by creation date, populate author and course info
    const posts = await ForumPost.find(filter)
      .populate('author', 'firstName lastName email')
      .populate('course', 'title')
      .sort({ createdAt: -1 });

    res.json(posts);
  })
);

// @route   GET /api/v1/forum/:id
// @desc    Get a single forum post by ID with replies
// @access  Private
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const post = await ForumPost.findById(req.params.id)
      .populate('author', 'firstName lastName email')
      .populate('course', 'title');

    if (!post) {
      res.status(404);
      throw new Error('Forum post not found');
    }

    // Fetch replies to this post
    const replies = await ForumPost.find({ parentPost: post._id })
      .populate('author', 'firstName lastName email')
      .sort({ createdAt: 1 });

    res.json({ post, replies });
  })
);

// @route   PATCH /api/v1/forum/:id
// @desc    Update a forum post (only author or coordinator)
// @access  Private
router.patch(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const post = await ForumPost.findById(req.params.id);

    if (!post) {
      res.status(404);
      throw new Error('Forum post not found');
    }

    // Only author or coordinator can update
    if (
      post.author.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to update this post');
    }

    const { content } = req.body;
    if (content !== undefined) post.content = content;

    // Optionally update isEdited flag
    post.isEdited = true;

    const updatedPost = await post.save();
    res.json(updatedPost);
  })
);

// @route   DELETE /api/v1/forum/:id
// @desc    Delete a forum post (only author or coordinator)
// @access  Private
router.delete(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const post = await ForumPost.findById(req.params.id);

    if (!post) {
      res.status(404);
      throw new Error('Forum post not found');
    }

    if (
      post.author.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to delete this post');
    }

    // Also delete replies if needed
    await ForumPost.deleteMany({ parentPost: post._id });

    await post.remove();

    res.json({ message: 'Forum post and its replies deleted successfully' });
  })
);

module.exports = router;

backend\routes\quizAttemptRoutes.js
// backend/routes/quizAttemptRoutes.js
const express = require('express');
const router = express.Router();
const QuizAttempt = require('../models/QuizAttempt');
const Quiz = require('../models/Quiz');
const { protect } = require('../middleware/auth');
const quizAttemptController = require('../controllers/quizAttemptController');

// âœ… Save a new quiz attempt (restrict to one per learner)
router.post('/', protect, async (req, res) => {
  try {
    const existing = await QuizAttempt.findOne({
      learner: req.user.id,
      quiz: req.body.quiz,
    });

    if (existing) {
      return res.status(400).json({ message: 'You have already attempted this quiz.' });
    }

    const newAttempt = new QuizAttempt({
      learner: req.user.id,
      quiz: req.body.quiz,
      answers: req.body.answers,
      score: req.body.score,
      totalQuestions: req.body.totalQuestions,
      attemptedAt: new Date(),
    });

    const saved = await newAttempt.save();

    // Optional: Add to Quiz.submissions[] if used in analytics
    await Quiz.findByIdAndUpdate(
      req.body.quiz,
      {
        $push: { submissions: { learner: req.user.id, score: req.body.score } },
      },
      { new: true }
    );

    res.status(201).json(saved);
  } catch (err) {
    res.status(500).json({ message: 'Failed to save attempt', error: err.message });
  }
});

// âœ… Get all attempts of the logged-in learner (history)
router.get('/my-attempts', protect, async (req, res) => {
  try {
    const attempts = await QuizAttempt.find({ learner: req.user.id })
      .populate('quiz', 'title')
      .sort({ attemptedAt: -1 });

    res.json(attempts);
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch attempts', error: err.message });
  }
});

// âœ… Check if learner already attempted a specific quiz
router.get('/my/:quizId', protect, async (req, res) => {
  try {
    const existing = await QuizAttempt.findOne({
      learner: req.user.id,
      quiz: req.params.quizId,
    });

    if (existing) {
      return res.json({ attempted: true });
    }

    res.json({ attempted: false });
  } catch (err) {
    res.status(500).json({ message: 'Server error', error: err.message });
  }
});

// â• Optional: Alternate controller-based route support
router.post('/controller', protect, quizAttemptController.submitQuiz);
router.get('/mine', protect, quizAttemptController.getMyAttempts);



module.exports = router;

backend\routes\quizRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const Quiz = require('../models/Quiz');
const { protect, authorizeRoles } = require('../middleware/auth');

// @route   POST /api/v1/quizzes
// @desc    Create a new quiz
// @access  Private (educator, coordinator)
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const { title, course, questions, durationMinutes } = req.body;

    if (!title || !course || !questions || !Array.isArray(questions) || questions.length === 0) {
      res.status(400);
      throw new Error('Title, course, and at least one question are required');
    }

    const quiz = await Quiz.create({
      title,
      course,
      educator: req.user._id,
      questions,
      durationMinutes: durationMinutes || 30,
    });

    res.status(201).json(quiz);
  })
);

// @route   GET /api/v1/quizzes
// @desc    Get all quizzes (optionally filtered by course)
// @access  Private
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const { course } = req.query;
    const filter = {};

    if (course) {
      filter.course = course;
    }

    const quizzes = await Quiz.find(filter)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email')
      .sort({ createdAt: -1 });

    res.json(quizzes);
  })
);

// @route   GET /api/v1/quizzes/:id
// @desc    Get quiz by ID
// @access  Private
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const quiz = await Quiz.findById(req.params.id)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email');

    if (!quiz) {
      res.status(404);
      throw new Error('Quiz not found');
    }

    res.json(quiz);
  })
);

// @route   PATCH /api/v1/quizzes/:id
// @desc    Update quiz (only creator educator or coordinator)
// @access  Private
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const quiz = await Quiz.findById(req.params.id);

    if (!quiz) {
      res.status(404);
      throw new Error('Quiz not found');
    }

    if (
      quiz.educator.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to update this quiz');
    }

    const { title, questions, durationMinutes } = req.body;

    if (title !== undefined) quiz.title = title;
    if (questions !== undefined) quiz.questions = questions;
    if (durationMinutes !== undefined) quiz.durationMinutes = durationMinutes;

    const updatedQuiz = await quiz.save();
    res.json(updatedQuiz);
  })
);

// @route   DELETE /api/v1/quizzes/:id
// @desc    Delete quiz (only creator educator or coordinator)
// @access  Private
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const quiz = await Quiz.findById(req.params.id);

    if (!quiz) {
      res.status(404);
      throw new Error('Quiz not found');
    }

    if (
      quiz.educator.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to delete this quiz');
    }

    await quiz.remove();
    res.json({ message: 'Quiz deleted successfully' });
  })
);

// @route PATCH /api/v1/quizzes/publish/:id
router.patch(
  '/publish/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const quiz = await Quiz.findById(req.params.id);
    if (!quiz) return res.status(404).json({ message: 'Quiz not found' });

    if (quiz.educator.toString() !== req.user._id.toString() && req.user.role !== 'coordinator') {
      return res.status(403).json({ message: 'Not authorized to publish this quiz' });
    }

    quiz.published = true;
    await quiz.save();
    res.json({ message: 'Quiz published successfully', quiz });
  })
);


module.exports = router;

backend\routes\reportRoutes.js
// backend/routes/reportRoutes.js
const express = require('express');
const router = express.Router();
const Enrollment = require('../models/Enrollment');
const { generateReceiptZip } = require('../utils/reportUtils');
const { sendEmailWithAttachment } = require('../utils/sendEmail');
const path = require('path');
const fs = require('fs');

// âœ… Correctly import the middleware function
const { protect } = require('../middleware/auth');

const TEMP_ZIP_PATH = path.join(__dirname, '../temp/receipts.zip');

// Route: GET /api/reports/bulk-receipts
router.get('/bulk-receipts', protect, async (req, res) => {
  try {
    const role = req.user.role;
    if (role !== 'admin' && role !== 'coordinator') {
      return res.status(403).json({ message: 'Access denied' });
    }

    const enrollments = await Enrollment.find({ paymentStatus: 'success' })
      .populate('learner')
      .populate('course');

    await generateReceiptZip(enrollments, TEMP_ZIP_PATH);

    res.download(TEMP_ZIP_PATH, 'receipts.zip', (err) => {
      if (fs.existsSync(TEMP_ZIP_PATH)) {
        fs.unlinkSync(TEMP_ZIP_PATH);
      }
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'ZIP generation failed' });
  }
});

// Route: GET /api/reports/weekly-email
router.get('/weekly-email', protect, async (req, res) => {
  try {
    const enrollments = await Enrollment.find().populate('learner').populate('course');

    const stats = {
      total: enrollments.length,
      success: enrollments.filter(e => e.paymentStatus === 'success').length,
      failed: enrollments.filter(e => e.paymentStatus === 'failed').length,
      pending: enrollments.filter(e => e.paymentStatus === 'pending').length,
    };

    const body = `
      <h3>Weekly Enrollment Report</h3>
      <p>Total Enrollments: ${stats.total}</p>
      <p>Successful: ${stats.success}</p>
      <p>Failed: ${stats.failed}</p>
      <p>Pending: ${stats.pending}</p>
    `;

    await sendEmailWithAttachment({
      to: process.env.ADMIN_EMAIL,
      subject: 'Weekly Enrollment Report',
      html: body,
    });

    res.json({ message: 'Email sent successfully' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Email sending failed' });
  }
});

module.exports = router;

backend\routes\studentRoutes.js
// backend/routes/studentRoutes.js

const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');

const User = require('../models/User');
const Enrollment = require('../models/Enrollment');
const Submission = require('../models/Submission');

const { protect, authorizeRoles } = require('../middleware/auth');

// ==============================
// Learner-Specific Routes
// ==============================

// @route   GET /api/v1/students/me
// @desc    Get current logged-in learner profile
// @access  Private (learner)
router.get(
  '/me',
  protect,
  authorizeRoles('learner'),
  asyncHandler(async (req, res) => {
    const student = await User.findById(req.user._id).select('-password');
    if (!student) {
      res.status(404);
      throw new Error('Student not found');
    }
    res.json(student);
  })
);

// @route   PATCH /api/v1/students/profile
// @desc    Update current learner profile
// @access  Private (learner)
router.patch(
  '/profile',
  protect,
  authorizeRoles('learner'),
  asyncHandler(async (req, res) => {
    const student = await User.findById(req.user._id);
    if (!student) {
      res.status(404);
      throw new Error('Student not found');
    }

    const {
      firstName,
      lastName,
      phone,
      address,
      country,
      avatarUrl,
      dob,
      sex,
    } = req.body;

    if (firstName !== undefined) student.firstName = firstName;
    if (lastName !== undefined) student.lastName = lastName;
    if (phone !== undefined) student.phone = phone;
    if (address !== undefined) student.address = address;
    if (country !== undefined) student.country = country;
    if (avatarUrl !== undefined) student.avatarUrl = avatarUrl;
    if (dob !== undefined) student.dob = dob;
    if (sex !== undefined) student.sex = sex;

    const updatedStudent = await student.save();
    res.json(updatedStudent);
  })
);

// @route   GET /api/v1/students/enrollments
// @desc    Get all enrollments for logged-in learner
// @access  Private (learner)
router.get(
  '/enrollments',
  protect,
  authorizeRoles('learner'),
  asyncHandler(async (req, res) => {
    const enrollments = await Enrollment.find({ learner: req.user._id })
      .populate('course', 'title category startDate endDate')
      .sort({ enrollmentDate: -1 });

    res.json(enrollments);
  })
);

// @route   GET /api/v1/students/submissions
// @desc    Get all submissions by logged-in learner
// @access  Private (learner)
router.get(
  '/submissions',
  protect,
  authorizeRoles('learner'),
  asyncHandler(async (req, res) => {
    const submissions = await Submission.find({ learner: req.user._id })
      .populate({
        path: 'assignment',
        select: 'name dueDate course',
        populate: { path: 'course', select: 'title' },
      })
      .sort({ submittedAt: -1 });

    res.json(submissions);
  })
);

// ==============================
// Coordinator-Specific Routes
// ==============================

// @route   GET /api/v1/students
// @desc    Get all learners for management
// @access  Private (coordinator)
router.get(
  '/',
  protect,
  authorizeRoles('coordinator'),
  asyncHandler(async (req, res) => {
    const learners = await User.find({ role: 'learner' })
      .select('-password')
      .sort({ createdAt: -1 });

    res.json(learners);
  })
);

module.exports = router;

backend\routes\studyPlanRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const StudyPlan = require('../models/StudyPlan');
const Course = require('../models/Course');
const { protect, authorizeRoles } = require('../middleware/auth');

// âœ… Setup Multer for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadPath = 'uploads/study-materials';
    fs.mkdirSync(uploadPath, { recursive: true });
    cb(null, uploadPath);
  },
  filename: function (req, file, cb) {
    const ext = path.extname(file.originalname);
    const name = file.originalname.split('.')[0].replace(/\s+/g, '-');
    cb(null, `${name}-${Date.now()}${ext}`);
  },
});
const upload = multer({
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: function (req, file, cb) {
    const allowedTypes = ['.pdf', '.doc', '.docx', '.ppt', '.pptx'];
    const ext = path.extname(file.originalname).toLowerCase();
    if (!allowedTypes.includes(ext)) {
      return cb(new Error('Only PDF, Word, and PPT files are allowed.'));
    }
    cb(null, true);
  },
});

// @route   POST /api/v1/studyplans
// @desc    Create a new study plan
// @access  Private (educator, coordinator)
router.post(
  '/',
  protect,
  authorizeRoles('educator', 'coordinator'),
  upload.single('material'),
  asyncHandler(async (req, res) => {
    const { course, title, description, schedule } = req.body;

    if (!course || !title) {
      res.status(400);
      throw new Error('Course and title are required');
    }

    const courseDoc = await Course.findById(course);
    if (!courseDoc) {
      res.status(404);
      throw new Error('Course not found');
    }

    if (
      req.user.role === 'educator' &&
      courseDoc.educator.toString() !== req.user._id.toString()
    ) {
      res.status(403);
      throw new Error('Not authorized to create study plan for this course');
    }

    let parsedSchedule = [];
    if (schedule) {
      if (typeof schedule === 'string') {
        try {
          parsedSchedule = JSON.parse(schedule);
        } catch {
          res.status(400);
          throw new Error('Invalid schedule format');
        }
      } else if (Array.isArray(schedule)) {
        parsedSchedule = schedule;
      } else {
        res.status(400);
        throw new Error('Schedule must be an array or JSON string');
      }
    }

    const studyPlan = new StudyPlan({
      course,
      educator: req.user._id,
      title,
      description,
      schedule: parsedSchedule,
      materials: req.file
        ? [
            {
              fileName: req.file.originalname,
              fileUrl: `/uploads/study-materials/${req.file.filename}`,
            },
          ]
        : [],
    });

    await studyPlan.save();
    res.status(201).json(studyPlan);
  })
);

// @route   GET /api/v1/studyplans
// @desc    Get all study plans (optionally filtered by course)
// @access  Private (all authenticated)
router.get(
  '/',
  protect,
  asyncHandler(async (req, res) => {
    const { course } = req.query;
    const filter = {};
    if (course) {
      filter.course = course;
    }

    const studyPlans = await StudyPlan.find(filter)
      .populate('course', 'title startDate')
      .populate('educator', 'firstName lastName email')
      .sort({ createdAt: -1 });

    res.json(studyPlans);
  })
);

// @route   GET /api/v1/studyplans/:id
// @desc    Get study plan by ID
// @access  Private
router.get(
  '/:id',
  protect,
  asyncHandler(async (req, res) => {
    const studyPlan = await StudyPlan.findById(req.params.id)
      .populate('course', 'title')
      .populate('educator', 'firstName lastName email');

    if (!studyPlan) {
      res.status(404);
      throw new Error('Study plan not found');
    }

    res.json(studyPlan);
  })
);

// @route   PATCH /api/v1/studyplans/:id
// @desc    Update a study plan
// @access  Private (owner educator or coordinator)
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  upload.single('material'),
  asyncHandler(async (req, res) => {
    const studyPlan = await StudyPlan.findById(req.params.id);

    if (!studyPlan) {
      res.status(404);
      throw new Error('Study plan not found');
    }

    if (
      studyPlan.educator.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to update this study plan');
    }

    const { title, description, schedule } = req.body;

    if (title !== undefined) studyPlan.title = title;
    if (description !== undefined) studyPlan.description = description;
    if (schedule !== undefined) {
      if (typeof schedule === 'string') {
        try {
          studyPlan.schedule = JSON.parse(schedule);
        } catch {
          res.status(400);
          throw new Error('Invalid schedule format');
        }
      } else if (Array.isArray(schedule)) {
        studyPlan.schedule = schedule;
      } else {
        res.status(400);
        throw new Error('Schedule must be an array or JSON string');
      }
    }

    if (req.file) {
      studyPlan.materials.push({
        fileName: req.file.originalname,
        fileUrl: `/uploads/study-materials/${req.file.filename}`,
      });
    }

    const updated = await studyPlan.save();
    res.json(updated);
  })
);

// @route   DELETE /api/v1/studyplans/:id
// @desc    Delete a study plan
// @access  Private (owner educator or coordinator)
router.delete(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const studyPlan = await StudyPlan.findById(req.params.id);

    if (!studyPlan) {
      res.status(404);
      throw new Error('Study plan not found');
    }

    if (
      studyPlan.educator.toString() !== req.user._id.toString() &&
      req.user.role !== 'coordinator'
    ) {
      res.status(403);
      throw new Error('Not authorized to delete this study plan');
    }

    await studyPlan.remove();
    res.json({ message: 'Study plan deleted successfully' });
  })
);

module.exports = router;
backend\routes\submissionRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const JSZip = require('jszip');

const Submission = require('../models/Submission');
const Assignment = require('../models/Assignment');
const Course = require('../models/Course');
const User = require('../models/User');
const { protect, authorizeRoles } = require('../middleware/auth');
const sendEmail = require('../utils/sendEmail');

// Multer setup for PDF only
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const dir = path.join(__dirname, '../uploads/submissions');
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `${req.user._id}_${Date.now()}${ext}`);
  },
});
const fileFilter = (req, file, cb) => {
  if (file.mimetype === 'application/pdf') cb(null, true);
  else cb(new Error('Only PDF files are allowed'));
};
const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
});

// POST /api/v1/submissions
router.post(
  '/',
  protect,
  authorizeRoles('learner'),
  upload.single('file'),
  asyncHandler(async (req, res) => {
    const { assignment } = req.body;
    if (!assignment) throw new Error('Assignment ID is required');

    const assignmentDoc = await Assignment.findById(assignment).populate('course');
    if (!assignmentDoc) throw new Error('Assignment not found');
    if (!req.file) throw new Error('File is required');

    let submission = await Submission.findOne({ learner: req.user._id, assignment });

    if (submission) {
      const oldPath = path.join(__dirname, '../', submission.fileUrl);
      if (fs.existsSync(oldPath)) fs.unlinkSync(oldPath);

      submission.fileUrl = `uploads/submissions/${req.file.filename}`;
      submission.fileName = req.file.originalname;
      submission.submittedAt = new Date();
      submission.status = 'resubmitted';
      await submission.save();
    } else {
      submission = await Submission.create({
        assignment,
        learner: req.user._id,
        fileUrl: `uploads/submissions/${req.file.filename}`,
        fileName: req.file.originalname,
        status: 'submitted',
        submittedAt: new Date(),
      });
    }

    const educator = await User.findById(assignmentDoc.educator);
    const subject = `ğŸ“„ New Submission: ${assignmentDoc.name}`;
    const html = `
      <p><strong>Assignment:</strong> ${assignmentDoc.name}</p>
      <p><strong>Course:</strong> ${assignmentDoc.course?.title || '-'}</p>
      <p><strong>Learner:</strong> ${req.user.firstName} ${req.user.lastName}</p>
      <p><strong>Submitted at:</strong> ${new Date().toLocaleString()}</p>
    `;

    await sendEmail({
      to: req.user.email,
      subject: 'âœ… Submission Received',
      html,
    });

    if (educator?.email) {
      await sendEmail({
        to: educator.email,
        subject,
        html,
      });
    }

    res.status(201).json({ message: 'Submission saved', submission });
  })
);

// GET /api/v1/submissions
router.get(
  '/',
  protect,
  authorizeRoles('coordinator', 'educator', 'learner'),
  asyncHandler(async (req, res) => {
    const role = req.user.role;
    let filter = {};

    if (role === 'learner') {
      filter.learner = req.user._id;
    }

    const submissions = await Submission.find(filter)
      .populate({
        path: 'assignment',
        populate: { path: 'course', select: 'title' },
        select: 'name dueDate course',
      })
      .populate('learner', 'firstName lastName email')
      .sort({ submittedAt: -1 });

    res.json(submissions);
  })
);

// âœ… GET /api/v1/submissions/my (educator only)
router.get(
  '/my',
  protect,
  authorizeRoles('educator'),
  asyncHandler(async (req, res) => {
    const educatorId = req.user._id;

    const submissions = await Submission.find()
      .populate({
        path: 'assignment',
        match: { educator: educatorId },
        populate: { path: 'course', select: 'title' },
        select: 'name course dueDate'
      })
      .populate('learner', 'firstName lastName email')
      .sort({ submittedAt: -1 });

    const filtered = submissions.filter(s => s.assignment !== null);
    res.json(filtered);
  })
);

// âœ… GET /api/v1/submissions/my/zip (educator ZIP export)
router.get(
  '/my/zip',
  protect,
  authorizeRoles('educator'),
  asyncHandler(async (req, res) => {
    const educatorId = req.user._id;
    const submissions = await Submission.find()
      .populate({
        path: 'assignment',
        match: { educator: educatorId },
        select: 'name',
      });

    const filtered = submissions.filter(s => s.assignment !== null);
    const zip = new JSZip();

    for (const s of filtered) {
      const filePath = path.join(__dirname, '../', s.fileUrl);
      if (fs.existsSync(filePath)) {
        const fileData = fs.readFileSync(filePath);
        zip.file(s.fileName || path.basename(filePath), fileData);
      }
    }

    const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' });

    res.set('Content-Type', 'application/zip');
    res.set('Content-Disposition', 'attachment; filename=submissions.zip');
    res.send(zipBuffer);
  })
);

// PATCH /api/v1/submissions/:id
router.patch(
  '/:id',
  protect,
  authorizeRoles('educator', 'coordinator'),
  asyncHandler(async (req, res) => {
    const submission = await Submission.findById(req.params.id);
    if (!submission) throw new Error('Submission not found');

    const { grade, feedback, status } = req.body;
    if (grade !== undefined) submission.grade = grade;
    if (feedback !== undefined) submission.feedback = feedback;
    if (status !== undefined) submission.status = status;

    await submission.save();

    const learner = await User.findById(submission.learner);
    const assignment = await Assignment.findById(submission.assignment).populate('course');

    const html = `
      <p>Your assignment <strong>${assignment.name}</strong> for the course <strong>${assignment.course?.title}</strong> has been graded.</p>
      <p><strong>Grade:</strong> ${submission.grade}</p>
      <p><strong>Feedback:</strong> ${submission.feedback || 'No feedback provided'}</p>
    `;

    await sendEmail({
      to: learner.email,
      subject: `ğŸ“Š Graded: ${assignment.name}`,
      html,
    });

    res.json(submission);
  })
);

// DELETE /api/v1/submissions/:id
router.delete(
  '/:id',
  protect,
  authorizeRoles('coordinator'),
  asyncHandler(async (req, res) => {
    const submission = await Submission.findById(req.params.id);
    if (!submission) throw new Error('Submission not found');

    const filePath = path.join(__dirname, '../', submission.fileUrl);
    if (fs.existsSync(filePath)) fs.unlinkSync(filePath);

    await submission.remove();
    res.json({ message: 'Submission deleted' });
  })
);

module.exports = router;

backend\routes\userRoutes.js
const express = require('express');
const router = express.Router();
const asyncHandler = require('express-async-handler');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const User = require('../models/User');
const { protect, authorizeRoles } = require('../middleware/auth');

// Token generator
const generateToken = (id, role) => {
  return jwt.sign({ id, role }, process.env.JWT_SECRET || 'defaultsecret', { expiresIn: '7d' });
};

// âœ… Storage for avatar
const avatarStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../uploads/avatars');
    fs.mkdirSync(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const unique = `${req.user._id}-${Date.now()}${ext}`;
    cb(null, unique);
  },
});
const avatarUpload = multer({
  storage: avatarStorage,
  fileFilter: (req, file, cb) => {
    const allowed = ['image/jpeg', 'image/png', 'image/jpg'];
    allowed.includes(file.mimetype) ? cb(null, true) : cb(new Error('Only images allowed'));
  },
  limits: { fileSize: 2 * 1024 * 1024 }, // 2MB
});

// âœ… @route   POST /api/v1/users/register
router.post(
  '/register',
  asyncHandler(async (req, res) => {
    const { firstName, lastName, email, password, dob, sex, phone, address, country, role } = req.body;

    if (!firstName || !lastName || !email || !password || !dob || !sex || !role) {
      res.status(400);
      throw new Error('Please fill in all required fields');
    }

    const userExists = await User.findOne({ email: email.toLowerCase() });
    if (userExists) {
      res.status(400);
      throw new Error('Email already registered');
    }

    // âœ… Let the User model hash the password
    const user = await User.create({
      firstName,
      lastName,
      email: email.toLowerCase(),
      password,
      dob,
      sex,
      phone,
      address,
      country,
      role,
    });

    res.status(201).json({
      _id: user._id,
      firstName,
      lastName,
      email: user.email,
      role: user.role,
      token: generateToken(user._id, user.role),
    });
  })
);

// âœ… @route   POST /api/v1/users/login
router.post(
  '/login',
  asyncHandler(async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
      res.status(400);
      throw new Error('Please provide email and password');
    }

    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');

    if (!user) {
      res.status(401);
      throw new Error('Invalid email');
    }

    const isMatch = await bcrypt.compare(password, user.password || '');
    if (!isMatch) {
      res.status(401);
      throw new Error('Invalid password');
    }

    res.json({
      _id: user._id,
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email,
      role: user.role,
      avatarUrl: user.avatarUrl,
      token: generateToken(user._id, user.role),
    });
  })
);

// @route   GET /api/v1/users/profile
router.get(
  '/profile',
  protect,
  asyncHandler(async (req, res) => {
    const user = await User.findById(req.user._id).select('-password');
    if (!user) {
      res.status(404);
      throw new Error('User not found');
    }
    res.json(user);
  })
);

// @route   PATCH /api/v1/users/profile
router.patch(
  '/profile',
  protect,
  asyncHandler(async (req, res) => {
    const user = await User.findById(req.user._id).select('+password');
    if (!user) {
      res.status(404);
      throw new Error('User not found');
    }

    const { firstName, lastName, dob, sex, phone, address, country, password, avatarUrl } = req.body;

    if (firstName !== undefined) user.firstName = firstName;
    if (lastName !== undefined) user.lastName = lastName;
    if (dob !== undefined) user.dob = dob;
    if (sex !== undefined) user.sex = sex;
    if (phone !== undefined) user.phone = phone;
    if (address !== undefined) user.address = address;
    if (country !== undefined) user.country = country;
    if (avatarUrl !== undefined) user.avatarUrl = avatarUrl;

    if (password) user.password = password; // will be hashed by model

    const updated = await user.save();

    res.json({
      _id: updated._id,
      firstName: updated.firstName,
      lastName: updated.lastName,
      email: updated.email,
      role: updated.role,
      avatarUrl: updated.avatarUrl,
      token: generateToken(updated._id, updated.role),
    });
  })
);

// âœ… @route   POST /api/v1/users/upload-avatar
router.post(
  '/upload-avatar',
  protect,
  avatarUpload.single('avatar'),
  asyncHandler(async (req, res) => {
    if (!req.file) {
      res.status(400);
      throw new Error('No avatar file uploaded');
    }

    const user = await User.findById(req.user._id);
    if (!user) {
      res.status(404);
      throw new Error('User not found');
    }

    // Optionally delete previous avatar
    if (user.avatarUrl) {
      const oldPath = path.join(__dirname, '../', user.avatarUrl);
      if (fs.existsSync(oldPath)) fs.unlinkSync(oldPath);
    }

    user.avatarUrl = `uploads/avatars/${req.file.filename}`;
    await user.save();

    res.json({ avatarUrl: user.avatarUrl });
  })
);

// @route   GET /api/v1/users (coordinator only)
router.get(
  '/',
  protect,
  authorizeRoles('coordinator'),
  asyncHandler(async (req, res) => {
    const users = await User.find().select('-password').sort({ createdAt: -1 });
    res.json(users);
  })
);

// @route   DELETE /api/v1/users/:id
router.delete(
  '/:id',
  protect,
  authorizeRoles('coordinator'),
  asyncHandler(async (req, res) => {
    const user = await User.findById(req.params.id);
    if (!user) {
      res.status(404);
      throw new Error('User not found');
    }

    await user.remove();
    res.json({ message: 'User deleted successfully' });
  })
);

module.exports = router;

backend\index.js
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
const morgan = require('morgan');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const http = require('http');
const { Server } = require('socket.io');
const cron = require('node-cron');
const swaggerUi = require('swagger-ui-express');
const swaggerJsdoc = require('swagger-jsdoc');

const dashboardRoutes = require('./routes/dashboardRoutes'); // âœ… NEW
const footerRoutes = require('./routes/footerRoutes');
const reportRoutes = require('./routes/reportRoutes');
const enrollmentRoutes = require('./routes/enrollmentRoutes');
const { sendEmailWithAttachment } = require('./utils/sendEmail');
const quizAttemptRoutes = require('./routes/quizAttemptRoutes');
const quizRoutes = require('./routes/quizRoutes');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' },
});

// Swagger Setup
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Learning Platform API',
      version: '1.0.0',
      description: 'API documentation for Learning Platform',
    },
    servers: [{ url: `http://localhost:${process.env.PORT || 5000}` }],
  },
  apis: ['./routes/*.js'],
};
const swaggerSpec = swaggerJsdoc(swaggerOptions);

// Connect to MongoDB
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('âœ… MongoDB connected');
  } catch (err) {
    console.error('âŒ MongoDB connection error:', err.message);
    process.exit(1);
  }
};
connectDB();

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));

if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Swagger route
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Routes
app.get('/', (req, res) => {
  res.send('ğŸš€ API is running...');
});
app.use('/api/v1/users', require('./routes/userRoutes'));
app.use('/api/v1/students', require('./routes/studentRoutes'));
app.use('/api/v1/educators', require('./routes/educatorRoutes'));
app.use('/api/v1/courses', require('./routes/courseRoutes'));
app.use('/api/v1/enrollments', enrollmentRoutes); // âœ… Corrected (Only once)
app.use('/api/v1/studyplans', require('./routes/studyPlanRoutes'));
app.use('/api/v1/assignments', require('./routes/assignmentRoutes'));
app.use('/api/v1/submissions', require('./routes/submissionRoutes'));
app.use('/api/v1/evaluations', require('./routes/evaluationRoutes'));
app.use('/api/v1/forum', require('./routes/forumRoutes'));
app.use('/api/v1/zoom', require('./routes/doubtRoutes'));
app.use('/api/v1/dashboard', dashboardRoutes); // âœ… NEW - this is the fix
app.use('/api/v1', footerRoutes);
app.use('/api/reports', reportRoutes);
app.use('/uploads', express.static('uploads'));  // âœ… Make uploaded files available
app.use('/api/v1/quiz-attempts', quizAttemptRoutes);
app.use('/api/v1/quizzes', quizRoutes);
app.use('/api/v1/quizAttempts', quizAttemptRoutes);


// Socket.io Setup
io.on('connection', (socket) => {
  console.log(`ğŸ”Œ Client connected: ${socket.id}`);

  socket.on('joinRoom', (room) => {
    socket.join(room);
    console.log(`ğŸ‘¥ Client ${socket.id} joined room ${room}`);
  });

  socket.on('sendMessage', ({ room, message, user }) => {
    io.to(room).emit('receiveMessage', { message, user, timestamp: new Date() });
  });

  socket.on('disconnect', () => {
    console.log(`âŒ Client disconnected: ${socket.id}`);
  });
});

// 404 handler
app.use((req, res, next) => {
  res.status(404).json({ message: 'ğŸ” Route not found' });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('ğŸ’¥ Server Error:', err.stack);
  res.status(500).json({ message: 'Internal Server Error' });
});

// Cron Job: Weekly Email Report
cron.schedule('0 0 * * 0', async () => {
  try {
    console.log('ğŸ“¬ Sending weekly enrollment email...');
    await fetch(`http://localhost:${process.env.PORT || 5000}/api/reports/weekly-email`, {
      method: 'GET',
      headers: { Authorization: `Bearer ${process.env.ADMIN_CRON_TOKEN || ''}` },
    });
  } catch (error) {
    console.error('âŒ Failed to send weekly report:', error.message);
  }
});

// Start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`âœ… Server running on port ${PORT} in ${process.env.NODE_ENV} mode`);
  console.log(`ğŸ“š Swagger docs at http://localhost:${PORT}/api-docs`);
});
